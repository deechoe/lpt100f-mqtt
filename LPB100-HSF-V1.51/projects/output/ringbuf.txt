; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\ringbuf.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\ringbuf.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931,494 -I..\sdk\1.51\include -I..\..\usr -I..\..\mqtt -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -D__KEIL_MDK__ -D__LPT100F__ --enum_is_int --signed_chars --omf_browse=.\output\ringbuf.crf ..\..\usr\ringbuf.c]
                          THUMB

                          AREA ||i.rb_can_read||, CODE, READONLY, ALIGN=1

                  rb_can_read PROC
;;;33     }
;;;34     size_t     rb_can_read(RingBuffer *rb)
000000  b500              PUSH     {lr}
;;;35     {
000002  0001              MOVS     r1,r0
000004  d003              BEQ      |L1.14|
;;;36     	  if(rb==NULL)  return 0;
;;;37         if (rb->rb_head == rb->rb_tail) return 0;
000006  684a              LDR      r2,[r1,#4]
000008  6888              LDR      r0,[r1,#8]
00000a  4282              CMP      r2,r0
00000c  d102              BNE      |L1.20|
                  |L1.14|
00000e  f04f0000          MOV      r0,#0
;;;38         if (rb->rb_head < rb->rb_tail) return rb->rb_tail - rb->rb_head;
;;;39         return rb_capacity(rb) - (rb->rb_head - rb->rb_tail);
;;;40     }
000012  bd00              POP      {pc}
                  |L1.20|
000014  d202              BCS      |L1.28|
000016  eba00002          SUB      r0,r0,r2              ;38
00001a  bd00              POP      {pc}
                  |L1.28|
00001c  4608              MOV      r0,r1                 ;39
00001e  f7fffffe          BL       rb_capacity
000022  684a              LDR      r2,[r1,#4]            ;39
000024  6889              LDR      r1,[r1,#8]            ;39
000026  1a51              SUBS     r1,r2,r1              ;39
000028  1a40              SUBS     r0,r0,r1              ;39
00002a  bd00              POP      {pc}
;;;41     size_t     rb_can_write(RingBuffer *rb)
                          ENDP


                          AREA ||i.rb_can_write||, CODE, READONLY, ALIGN=1

                  rb_can_write PROC
;;;40     }
;;;41     size_t     rb_can_write(RingBuffer *rb)
000000  b500              PUSH     {lr}
;;;42     {
000002  0001              MOVS     r1,r0
000004  d007              BEQ      |L2.22|
;;;43     	  if(rb==NULL)  return 0;
;;;44         return rb_capacity(rb) - rb_can_read(rb);
000006  f7fffffe          BL       rb_capacity
00000a  4603              MOV      r3,r0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       rb_can_read
000012  1a18              SUBS     r0,r3,r0
;;;45     }
000014  bd00              POP      {pc}
                  |L2.22|
000016  2000              MOVS     r0,#0                 ;43
000018  bd00              POP      {pc}
;;;46     
                          ENDP


                          AREA ||i.rb_capacity||, CODE, READONLY, ALIGN=1

                  rb_capacity PROC
;;;28     
;;;29     size_t     rb_capacity(RingBuffer *rb)
000000  2800              CMP      r0,#0
;;;30     {
000002  d000              BEQ      |L3.6|
;;;31     	  if(rb==NULL)  return 0;
;;;32         return rb->rb_capacity;
000004  6800              LDR      r0,[r0,#0]
                  |L3.6|
;;;33     }
000006  4770              BX       lr
;;;34     size_t     rb_can_read(RingBuffer *rb)
                          ENDP


                          AREA ||i.rb_free||, CODE, READONLY, ALIGN=1

                  rb_free PROC
;;;20     
;;;21     void  rb_free(RingBuffer *rb)
000000  2100              MOVS     r1,#0
;;;22     {
;;;23     		rb->rb_capacity = 0;		
000002  6001              STR      r1,[r0,#0]
;;;24     	  rb->rb_buff     = NULL;
000004  60c1              STR      r1,[r0,#0xc]
;;;25     		rb->rb_head     = NULL;
000006  6041              STR      r1,[r0,#4]
;;;26     		rb->rb_tail     = NULL;	
000008  6081              STR      r1,[r0,#8]
;;;27     }
00000a  4770              BX       lr
;;;28     
                          ENDP


                          AREA ||i.rb_new||, CODE, READONLY, ALIGN=1

                  rb_new PROC
;;;12     //static char buff[512] = {0};
;;;13     void rb_new(RingBuffer* rb,uint8_t *rbuff,uint16_t len)
000000  6002              STR      r2,[r0,#0]
;;;14     {
;;;15         rb->rb_capacity = len;//-sizeof(RingBuffer);//capacity;
;;;16     	  rb->rb_buff     = rbuff;    
000002  60c1              STR      r1,[r0,#0xc]
;;;17     	  rb->rb_head     = rb->rb_buff;
000004  6041              STR      r1,[r0,#4]
;;;18         rb->rb_tail     = rb->rb_buff;
000006  6081              STR      r1,[r0,#8]
;;;19     };
000008  4770              BX       lr
;;;20     
                          ENDP


                          AREA ||i.rb_read||, CODE, READONLY, ALIGN=1

                  rb_read PROC
;;;46     
;;;47     size_t     rb_read(RingBuffer *rb, void *data, size_t count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;48     {
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d00e              BEQ      |L6.42|
;;;49     	  if(rb==NULL)  return 0;
;;;50         if (rb->rb_head < rb->rb_tail)
00000c  6860              LDR      r0,[r4,#4]
00000e  68a1              LDR      r1,[r4,#8]
000010  4288              CMP      r0,r1
;;;51         {
;;;52             int copy_sz = min(count, rb_can_read(rb));
;;;53             memcpy(data, rb->rb_head, copy_sz);
;;;54             rb->rb_head += copy_sz;
;;;55             return copy_sz;
;;;56         }
;;;57         else
;;;58         {
;;;59             if (count < rb_capacity(rb)-(rb->rb_head - rb->rb_buff))
000012  4620              MOV      r0,r4
000014  d20c              BCS      |L6.48|
000016  f7fffffe          BL       rb_can_read
00001a  42a8              CMP      r0,r5                 ;52
00001c  d803              BHI      |L6.38|
00001e  4620              MOV      r0,r4                 ;52
000020  f7fffffe          BL       rb_can_read
000024  4605              MOV      r5,r0                 ;52
                  |L6.38|
000026  6861              LDR      r1,[r4,#4]            ;53
000028  e00a              B        |L6.64|
                  |L6.42|
00002a  2000              MOVS     r0,#0                 ;49
                  |L6.44|
;;;60             {
;;;61                 int copy_sz = count;
;;;62                 memcpy(data, rb->rb_head, copy_sz);
;;;63                 rb->rb_head += copy_sz;
;;;64                 return copy_sz;
;;;65             }
;;;66             else
;;;67             {
;;;68                 int copy_sz = rb_capacity(rb) - (rb->rb_head - rb->rb_buff);
;;;69                 memcpy(data, rb->rb_head, copy_sz);
;;;70                 rb->rb_head = rb->rb_buff;
;;;71                 copy_sz += rb_read(rb, (char*)data+copy_sz, count-copy_sz);
;;;72                 return copy_sz;
;;;73             }
;;;74         }
;;;75     }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L6.48|
000030  f7fffffe          BL       rb_capacity
000034  6861              LDR      r1,[r4,#4]            ;59
000036  68e2              LDR      r2,[r4,#0xc]          ;59
000038  1a8a              SUBS     r2,r1,r2              ;59
00003a  1a80              SUBS     r0,r0,r2              ;59
00003c  42a8              CMP      r0,r5                 ;59
00003e  d908              BLS      |L6.82|
                  |L6.64|
000040  462a              MOV      r2,r5                 ;62
000042  4638              MOV      r0,r7                 ;62
000044  f7fffffe          BL       __aeabi_memcpy
000048  6860              LDR      r0,[r4,#4]            ;63
00004a  4428              ADD      r0,r0,r5              ;63
00004c  6060              STR      r0,[r4,#4]            ;63
00004e  4628              MOV      r0,r5                 ;64
000050  e7ec              B        |L6.44|
                  |L6.82|
000052  4620              MOV      r0,r4                 ;68
000054  f7fffffe          BL       rb_capacity
000058  6861              LDR      r1,[r4,#4]            ;68
00005a  68e2              LDR      r2,[r4,#0xc]          ;68
00005c  1a8a              SUBS     r2,r1,r2              ;68
00005e  1a86              SUBS     r6,r0,r2              ;68
000060  4632              MOV      r2,r6                 ;69
000062  4638              MOV      r0,r7                 ;69
000064  f7fffffe          BL       __aeabi_memcpy
000068  68e0              LDR      r0,[r4,#0xc]          ;70
00006a  6060              STR      r0,[r4,#4]            ;70
00006c  1baa              SUBS     r2,r5,r6              ;71
00006e  19b9              ADDS     r1,r7,r6              ;71
000070  4620              MOV      r0,r4                 ;71
000072  f7fffffe          BL       rb_read
000076  4430              ADD      r0,r0,r6              ;71
000078  e7d8              B        |L6.44|
;;;76     
                          ENDP


                          AREA ||i.rb_write||, CODE, READONLY, ALIGN=1

                  rb_write PROC
;;;76     
;;;77     size_t     rb_write(RingBuffer *rb, const void *data, size_t count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;78     {
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d003              BEQ      |L7.20|
;;;79     	  if(rb==NULL)  return 0;
;;;80         if (count >= rb_can_write(rb)) 
00000c  f7fffffe          BL       rb_can_write
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L7.26|
                  |L7.20|
;;;81     			return 0;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;82         
;;;83         if (rb->rb_head <= rb->rb_tail)
;;;84         {
;;;85             int tail_avail_sz = rb_capacity(rb) - (rb->rb_tail - rb->rb_buff);
;;;86             if (count <= tail_avail_sz)
;;;87             {
;;;88                 memcpy(rb->rb_tail, data, count);
;;;89                 rb->rb_tail += count;
;;;90                 if (rb->rb_tail == rb->rb_buff+rb_capacity(rb))
;;;91                     rb->rb_tail = rb->rb_buff;
;;;92                 return count;
;;;93             }
;;;94             else
;;;95             {
;;;96                 memcpy(rb->rb_tail, data, tail_avail_sz);
;;;97                 rb->rb_tail = rb->rb_buff;
;;;98                 
;;;99                 return tail_avail_sz + rb_write(rb, (char*)data+tail_avail_sz, count-tail_avail_sz);
;;;100            }
;;;101        }
;;;102        else
;;;103        {
;;;104            memcpy(rb->rb_tail, data, count);
;;;105            rb->rb_tail += count;
;;;106            return count;
;;;107        }
;;;108    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  6861              LDR      r1,[r4,#4]            ;83
00001c  68a0              LDR      r0,[r4,#8]            ;83
00001e  4281              CMP      r1,r0                 ;83
000020  d829              BHI      |L7.118|
000022  4620              MOV      r0,r4                 ;85
000024  f7fffffe          BL       rb_capacity
000028  4601              MOV      r1,r0                 ;85
00002a  68a0              LDR      r0,[r4,#8]            ;85
00002c  68e2              LDR      r2,[r4,#0xc]          ;85
00002e  1a82              SUBS     r2,r0,r2              ;85
000030  1a8e              SUBS     r6,r1,r2              ;85
000032  42b5              CMP      r5,r6                 ;86
000034  d812              BHI      |L7.92|
000036  462a              MOV      r2,r5                 ;88
000038  4639              MOV      r1,r7                 ;88
00003a  f7fffffe          BL       __aeabi_memcpy
00003e  68a0              LDR      r0,[r4,#8]            ;89
000040  4428              ADD      r0,r0,r5              ;89
000042  60a0              STR      r0,[r4,#8]            ;89
000044  4620              MOV      r0,r4                 ;90
000046  f7fffffe          BL       rb_capacity
00004a  4601              MOV      r1,r0                 ;90
00004c  68e0              LDR      r0,[r4,#0xc]          ;90
00004e  68a2              LDR      r2,[r4,#8]            ;90
000050  4401              ADD      r1,r1,r0              ;90
000052  4291              CMP      r1,r2                 ;90
000054  d100              BNE      |L7.88|
                  |L7.86|
000056  60a0              STR      r0,[r4,#8]            ;91
                  |L7.88|
000058  4628              MOV      r0,r5                 ;92
00005a  e7dc              B        |L7.22|
                  |L7.92|
00005c  4632              MOV      r2,r6                 ;96
00005e  4639              MOV      r1,r7                 ;96
000060  f7fffffe          BL       __aeabi_memcpy
000064  68e0              LDR      r0,[r4,#0xc]          ;97
000066  60a0              STR      r0,[r4,#8]            ;97
000068  1baa              SUBS     r2,r5,r6              ;99
00006a  19b9              ADDS     r1,r7,r6              ;99
00006c  4620              MOV      r0,r4                 ;99
00006e  f7fffffe          BL       rb_write
000072  4430              ADD      r0,r0,r6              ;99
000074  e7cf              B        |L7.22|
                  |L7.118|
000076  462a              MOV      r2,r5                 ;104
000078  4639              MOV      r1,r7                 ;104
00007a  f7fffffe          BL       __aeabi_memcpy
00007e  68a0              LDR      r0,[r4,#8]            ;105
000080  4428              ADD      r0,r0,r5              ;105
000082  e7e8              B        |L7.86|
                          ENDP

